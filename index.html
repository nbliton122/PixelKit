<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Passport Generator — remove.bg client</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  body{font-family:Inter,system-ui,Arial;background:#06151a;color:#d8fbff;margin:0;padding:18px}
  .wrap{max-width:1100px;margin:0 auto}
  h1{color:#7fefff;margin:6px 0 12px}
  .panel{background:#071824;padding:14px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.45)}
  .row{display:flex;gap:10px;align-items:center;margin:10px 0}
  label{min-width:120px;color:#9fe7f7}
  canvas{background:#0b2430;border-radius:8px;max-width:100%}
  .btn{background:linear-gradient(90deg,#00e6ff,#b86bff);color:#071824;padding:8px 12px;border-radius:20px;border:none;cursor:pointer}
  .small{background:#0b2b34;color:#9fe7f7;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  .log{white-space:pre-wrap;color:#9ad9ea;padding:10px;background:rgba(255,255,255,0.01);border-radius:8px;min-height:160px}
  .hint{color:#9ad9ea;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Passport Generator — remove.bg (client)</h1>

  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <strong style="color:#bff6ff">Upload portrait</strong>
        <div class="hint">This version calls remove.bg directly from your browser using the API key below.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <input id="file" type="file" accept="image/*">
        <button id="btnGo" class="btn">Remove BG & Generate</button>
      </div>
    </div>

    <div style="display:flex;gap:20px;margin-top:12px;flex-wrap:wrap">
      <div style="flex-basis:420px">
        <canvas id="preview" width="360" height="456"></canvas>
        <div style="margin-top:8px;color:#9ad9ea">Preview (export 450×570)</div>
      </div>

      <div style="flex:1;min-width:320px">
        <div class="row"><label>Background</label>
          <select id="bgSel"><option value="#5d8fe0">Passport blue (default)</option><option value="#ffffff">White</option><option value="custom">Custom</option></select>
          <input id="bgColor" type="color" value="#5d8fe0" style="display:none">
        </div>

        <div class="row"><label>Brightness</label><input id="brightness" type="range" min="-80" max="80" value="6"><div id="bVal" style="width:40px;text-align:right;color:#9ad9ea">+6</div></div>
        <div class="row"><label>Contrast</label><input id="contrast" type="range" min="-80" max="80" value="6"><div id="cVal" style="width:40px;text-align:right;color:#9ad9ea">+6</div></div>
        <div class="row"><label>Feather</label><input id="feather" type="range" min="0" max="30" value="6"><div id="fVal" style="width:40px;text-align:right;color:#9ad9ea">6px</div></div>

        <div style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
          <button id="downloadPng" class="small">Download PNG</button>
          <button id="downloadJpg" class="small">Download JPG</button>
          <button id="downloadPsd" class="small">Download PSD</button>
          <button id="reset" class="small">Reset</button>
        </div>

        <div style="margin-top:10px" class="hint">Export size: 450×570 px (1.5 × 1.9 in @ 300 DPI). If remove.bg call fails due to CORS, you will need a small proxy server (I can provide).</div>
      </div>
    </div>

    <div style="margin-top:12px" class="log" id="log">Ready. Paste your remove.bg API key in the code variable (REMOVE_BG_KEY) if not already set.</div>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/ag-psd@12.0.0/dist/ag-psd.umd.min.js"></script>

<script>
/*
  WARNING: This page uses your remove.bg API key directly in the browser.
  You've said API leak is okay — key is included below. If you change your mind,
  delete the key from this file and use a server proxy instead.
*/

// ====== Put your remove.bg API key here (you provided this earlier) ======
const REMOVE_BG_KEY = 'jDDFFQjTtwEmhRHP1izPBt5B'; // <-- YOUR KEY (exposed in client)

// Elements
const fileInput = document.getElementById('file');
const btnGo = document.getElementById('btnGo');
const preview = document.getElementById('preview');
const ctx = preview.getContext('2d');
const logEl = document.getElementById('log');
const bgSel = document.getElementById('bgSel');
const bgColor = document.getElementById('bgColor');
const brightness = document.getElementById('brightness');
const contrast = document.getElementById('contrast');
const feather = document.getElementById('feather');
const bVal = document.getElementById('bVal'), cVal = document.getElementById('cVal'), fVal = document.getElementById('fVal');
const dlPng = document.getElementById('downloadPng'), dlJpg = document.getElementById('downloadJpg'), dlPsd = document.getElementById('downloadPsd');
const resetBtn = document.getElementById('reset');

let uploadedFile = null;
let finalCanvas = null;

// UI helpers
function log(...t){ logEl.textContent += t.join(' ') + '\\n'; logEl.scrollTop = 9999; }
bgSel.addEventListener('change', ()=> bgColor.style.display = bgSel.value === 'custom' ? 'inline-block' : 'none');
brightness.addEventListener('input', ()=> bVal.textContent = (brightness.value>0?'+':'')+brightness.value);
contrast.addEventListener('input', ()=> cVal.textContent = (contrast.value>0?'+':'')+contrast.value);
feather.addEventListener('input', ()=> fVal.textContent = feather.value + 'px');

fileInput.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  uploadedFile = f;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=> {
    drawPreview(img);
    URL.revokeObjectURL(url);
    log('Image loaded: ' + img.width + '×' + img.height);
  };
  img.src = url;
});

btnGo.addEventListener('click', async ()=>{
  if(!uploadedFile) return alert('Please choose an image first.');
  try{
    log('Uploading to remove.bg ...');
    const processedBlob = await callRemoveBg(uploadedFile);
    log('remove.bg returned image (transparent). Compositing now...');
    const img = await blobToImage(processedBlob);
    // composite on chosen bg and apply edits
    const composed = compositeOnBg(img);
    finalCanvas = composed;
    // show preview scaled
    preview.width = Math.min(420, composed.width);
    preview.height = Math.round(preview.width * composed.height / composed.width);
    ctx.clearRect(0,0,preview.width,preview.height);
    ctx.drawImage(composed, 0,0, composed.width, composed.height, 0,0, preview.width, preview.height);
    log('Done. You can download PNG/JPG/PSD now.');
  }catch(err){
    console.error(err);
    log('Error: ' + (err.message || err));
    alert('Error: ' + (err.message || err));
  }
});

// call remove.bg API (client-side)
async function callRemoveBg(file){
  const url = 'https://api.remove.bg/v1.0/removebg';
  const form = new FormData();
  form.append('image_file', file);
  form.append('size', 'auto');
  const res = await fetch(url, {
    method: 'POST',
    headers: {
      'X-Api-Key': REMOVE_BG_KEY
      // DO NOT set Content-Type — browser manages multipart boundary
    },
    body: form
  });
  if(!res.ok){
    const text = await res.text();
    throw new Error('remove.bg failed: ' + res.status + ' ' + text);
  }
  return await res.blob(); // PNG (transparent)
}

function blobToImage(blob){
  return new Promise((resolve, reject)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}

// composite transparent person image onto chosen background, apply filters, and return canvas sized 450x570
function compositeOnBg(personImg){
  const OUT_W = 450, OUT_H = 570;
  const c = document.createElement('canvas'); c.width = OUT_W; c.height = OUT_H;
  const cctx = c.getContext('2d');

  // background color
  const bg = bgSel.value === 'custom' ? bgColor.value : bgSel.value;
  cctx.fillStyle = bg || '#5d8fe0';
  cctx.fillRect(0,0,OUT_W,OUT_H);

  // determine draw size to fit personImg to output while keeping aspect ratio and center crop
  // scale personImg such that its shorter side fits the canvas with some margin
  const scale = Math.min(personImg.width / personImg.width, personImg.height / personImg.height); // dummy (we'll compute differently)
  // We'll center-fit: compute scale to fit into OUT with cropping allowed
  const srcRatio = personImg.width / personImg.height;
  const destRatio = OUT_W / OUT_H;
  let drawW = OUT_W, drawH = OUT_H;
  if(srcRatio > destRatio){
    // source wider -> full height, crop width
    drawH = OUT_H;
    drawW = Math.round(personImg.width * (OUT_H / personImg.height));
  } else {
    drawW = OUT_W;
    drawH = Math.round(personImg.height * (OUT_W / personImg.width));
  }
  // draw centered
  const dx = Math.round((OUT_W - drawW)/2);
  const dy = Math.round((OUT_H - drawH)/2);
  cctx.drawImage(personImg, dx, dy, drawW, drawH);

  // Now apply simple adjustments on the composed canvas
  applyBrightnessContrast(c, Number(brightness.value), Number(contrast.value));

  // optional: despill (reduce blue fringe) — simple heuristic
  despillCanvas(c, bg || '#5d8fe0', 0.85);

  return c;
}

// brightness & contrast (basic, per-pixel)
function applyBrightnessContrast(canvas, bright=0, contrast=0){
  const ctx2 = canvas.getContext('2d');
  const img = ctx2.getImageData(0,0,canvas.width,canvas.height);
  const data = img.data;
  const b = bright;
  const c = contrast/100;
  const factor = (259 * (c*255 + 255)) / (255 * (259 - c*255) || 1);
  for(let i=0;i<data.length;i+=4){
    data[i] = clamp(factor * (clamp(data[i] + b) - 128) + 128);
    data[i+1] = clamp(factor * (clamp(data[i+1] + b) - 128) + 128);
    data[i+2] = clamp(factor * (clamp(data[i+2] + b) - 128) + 128);
  }
  ctx2.putImageData(img,0,0);
}

// despill: reduce blue-heavy fringe
function despillCanvas(canvas, bgHex='#5d8fe0', strength=0.85){
  const ctx2 = canvas.getContext('2d');
  const img = ctx2.getImageData(0,0,canvas.width,canvas.height);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    if(b > r + 12 && b > g + 12){
      const diff = b - Math.max(r,g);
      const reduce = Math.round(diff * strength);
      d[i+2] = clamp(b - reduce);
      // slightly boost r/g for natural
      d[i] = clamp(r + Math.round(reduce * 0.05));
      d[i+1] = clamp(g + Math.round(reduce * 0.03));
    }
  }
  ctx2.putImageData(img,0,0);
}

function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }

// downloads
dlPng.addEventListener('click', ()=> {
  if(!finalCanvas) return alert('Generate first');
  finalCanvas.toBlob(b=> saveBlob(b,'passport.png'), 'image/png');
});
dlJpg.addEventListener('click', ()=> {
  if(!finalCanvas) return alert('Generate first');
  finalCanvas.toBlob(b=> saveBlob(b,'passport.jpg'), 'image/jpeg', 0.92);
});
dlPsd.addEventListener('click', ()=> {
  if(!finalCanvas) return alert('Generate first');
  try{
    const ag = window['agPsd'];
    const psd = { width: finalCanvas.width, height: finalCanvas.height, children: [ { name: 'Layer 1', left:0, top:0, right: finalCanvas.width, bottom: finalCanvas.height, canvas: finalCanvas } ] };
    const ab = ag.encodePsd(psd);
    const blob = new Blob([ab], { type: 'application/octet-stream' });
    saveBlob(blob, 'passport.psd');
  }catch(e){
    alert('PSD export failed: ' + (e.message || e));
  }
});

function saveBlob(blob, name){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(a.href), 2000);
}

function saveAsFile(dataUrl, filename){
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

// helper to convert blob to Image
function blobToImage(blob){
  return new Promise((res, rej)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); res(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); rej(e); };
    img.src = url;
  });
}

// reset
resetBtn.addEventListener('click', ()=>{
  uploadedFile = null; finalCanvas = null; file.value = ''; ctx.clearRect(0,0,preview.width,preview.height); log('Reset.');
});

// small helper: if remove.bg response is a JSON error, throw message
async function fetchWithTimeout(url, opts={}, timeout=60000){
  const controller = new AbortController();
  const id = setTimeout(()=> controller.abort(), timeout);
  try{
    const res = await fetch(url, { ...opts, signal: controller.signal });
    clearTimeout(id);
    return res;
  }catch(e){
    clearTimeout(id);
    throw e;
  }
}

// call remove.bg but with timeout and better error message
async function callRemoveBg(file){
  const url = 'https://api.remove.bg/v1.0/removebg';
  const form = new FormData();
  form.append('image_file', file);
  form.append('size', 'auto');

  const res = await fetchWithTimeout(url, {
    method: 'POST',
    headers: { 'X-Api-Key': REMOVE_BG_KEY },
    body: form
  }, 60000);

  if(!res.ok){
    const t = await res.text();
    throw new Error('remove.bg error: ' + res.status + ' ' + t);
  }
  return await res.blob();
}
</script>
</body>
</html>
