<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Passport Size Pic Generator — PixelKit</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Orbitron:wght@600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#041018;
    --panel:#071824;
    --accent1:#00e6ff;
    --accent2:#b86bff;
    --sample-blue:#5d8fe0;
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Arial;margin:0;background:linear-gradient(180deg,#031017 0%, #041018 60%);color:#dbeef7;padding:22px}
  .wrap{max-width:1100px;margin:0 auto}
  h1{font-family:Orbitron, sans-serif;color:var(--accent1);margin:0 0 12px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03)); padding:16px;border-radius:12px; box-shadow: 0 8px 30px rgba(11,20,30,0.6);}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:18px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .right{order:-1} }

  .uploader{display:flex;gap:12px;align-items:center}
  input[type="file"]{background:#0b2028;color:#bff6ff;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .btn{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#071824;padding:10px 14px;border-radius:30px;text-decoration:none;border:none;font-weight:700;cursor:pointer}
  .small{padding:8px 10px;border-radius:8px;background:#0b2028;color:var(--accent1);border:1px solid rgba(0,230,255,0.06);cursor:pointer}
  .controls{display:flex;flex-direction:column;gap:10px;margin-top:12px}
  .row{display:flex;gap:8px;align-items:center}
  label{min-width:110px;color:#9ad9ea;font-size:14px}
  input[type=range]{flex:1}
  canvas{background:#0c1b22;border-radius:8px;display:block;width:100%;height:auto;max-width:420px}
  .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .log{font-size:13px;color:#9ad9ea;min-height:220px;white-space:pre-wrap;overflow:auto;padding:12px;background:rgba(255,255,255,0.01);border-radius:8px}
  footer{margin-top:16px;color:#7fb5c9;font-size:13px}
  .hint{font-size:13px;color:#8fbfd0}
</style>
</head>
<body>
<div class="wrap">
  <h1>Passport Size Pic Generator</h1>

  <div class="grid">
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:700;color:#bff6ff">Upload a portrait</div>
            <div class="hint">Any person photo — background will be removed and replaced with passport-blue by default.</div>
          </div>
          <div class="uploader">
            <input id="fileInput" type="file" accept="image/*">
            <button id="autoProcess" class="btn">Auto Process</button>
          </div>
        </div>

        <div style="margin-top:12px;display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap">
          <div>
            <canvas id="preview" width="360" height="456"></canvas>
            <div style="margin-top:8px;color:#9ad9ea;font-size:13px">Preview (export 450×570 px)</div>
          </div>

          <div style="min-width:260px;flex:1">
            <div class="controls">
              <div class="row">
                <label>Background</label>
                <select id="bgSelect">
                  <option value="preset">Match sample blue</option>
                  <option value="white">White</option>
                  <option value="custom">Custom</option>
                </select>
                <input id="bgColor" type="color" value="#5d8fe0" style="display:none">
              </div>

              <div class="row">
                <label>Brightness</label>
                <input id="brightness" type="range" min="-80" max="80" value="10">
                <div id="bVal" style="width:40px;text-align:right">+10</div>
              </div>

              <div class="row">
                <label>Contrast</label>
                <input id="contrast" type="range" min="-80" max="80" value="6">
                <div id="cVal" style="width:40px;text-align:right">+6</div>
              </div>

              <div class="row">
                <label>Sharpen</label>
                <input id="sharpen" type="range" min="0" max="3" step="0.25" value="1">
                <div id="sVal" style="width:40px;text-align:right">1.0</div>
              </div>

              <div class="row">
                <label>Feather (edge)</label>
                <input id="feather" type="range" min="0" max="20" value="8">
                <div id="fVal" style="width:40px;text-align:right">8px</div>
              </div>

              <div class="actions">
                <button id="applyBtn" class="btn">Apply & Generate</button>
                <button id="dlPng" class="small">Download PNG (450×570)</button>
                <button id="dlJpg" class="small">Download JPG</button>
                <button id="dlPsd" class="small">Download PSD (single-layer)</button>
                <button id="resetBtn" class="small">Reset</button>
              </div>

              <div class="hint" style="margin-top:6px">Export: 1.5 × 1.9 in @ 300 DPI = 450 × 570 px. For better edges upload clear, well-lit portrait.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <strong style="color:#bff6ff">Preview / Logs</strong>
        <div id="log" class="log">Loading BodyPix model...</div>
      </div>

      <div style="height:12px"></div>

      <div class="panel">
        <strong style="color:#bff6ff">How it works</strong>
        <ol style="color:#9ad9ea">
          <li>Load BodyPix model in browser (person segmentation)</li>
          <li>Create mask → blur/feather edges → composite over blue background</li>
          <li>Apply brightness / contrast / sharpen → crop to passport ratio → export</li>
        </ol>
      </div>
    </div>
  </div>

  <footer>Client-only solution. For pro layered PSD / hair-edge perfection use server-side processing (I can implement).</footer>
</div>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ag-psd@12.0.0/dist/ag-psd.umd.min.js"></script>

<script>
(async function(){
  // UI refs
  const fileInput = id('fileInput'), autoProcess = id('autoProcess');
  const preview = id('preview'), ctx = preview.getContext('2d');
  const applyBtn = id('applyBtn'), resetBtn = id('resetBtn');
  const dlPng = id('dlPng'), dlJpg = id('dlJpg'), dlPsd = id('dlPsd');
  const bgSelect = id('bgSelect'), bgColor = id('bgColor');
  const brightness = id('brightness'), contrast = id('contrast'), sharpen = id('sharpen');
  const feather = id('feather');
  const bVal = id('bVal'), cVal = id('cVal'), sVal = id('sVal'), fVal = id('fVal');
  const logEl = id('log');

  function log(...t){ logEl.textContent += t.join(' ') + "\n"; logEl.scrollTop = 9999; }

  // export size
  const EXPORT_W = 450, EXPORT_H = 570;

  // state
  let originalImage = null;
  let bodyPixNet = null;
  let latestCanvas = null;

  // load BodyPix (higher accuracy)
  log('Loading BodyPix model (high accuracy) — this may take a few seconds...');
  try{
    bodyPixNet = await bodyPix.load({ architecture: 'MobileNetV1', multiplier: 1.0, outputStride: 16 });
    log('BodyPix loaded.');
  }catch(e){
    log('BodyPix load failed:', e.message || e);
    bodyPixNet = null;
  }

  // UI events
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      drawPreviewScaled(img);
      URL.revokeObjectURL(url);
      log('Image loaded: ' + img.width + '×' + img.height);
    };
    img.src = url;
  });

  autoProcess.addEventListener('click', ()=> applyAndProcess());
  applyBtn.addEventListener('click', ()=> applyAndProcess());
  resetBtn.addEventListener('click', ()=> {
    originalImage = null;
    ctx.clearRect(0,0,preview.width,preview.height);
    fileInput.value = '';
    log('Reset.');
  });

  bgSelect.addEventListener('change', ()=> { bgColor.style.display = bgSelect.value === 'custom' ? 'inline-block' : 'none'; });
  brightness.addEventListener('input', ()=> bVal.textContent = (brightness.value>0?'+':'')+brightness.value);
  contrast.addEventListener('input', ()=> cVal.textContent = (contrast.value>0?'+':'')+contrast.value);
  sharpen.addEventListener('input', ()=> sVal.textContent = sharpen.value);
  feather.addEventListener('input', ()=> fVal.textContent = feather.value + 'px');

  dlPng.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Generate first.');
    latestCanvas.toBlob(b => saveAs(b,'passport.png'), 'image/png');
  });
  dlJpg.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Generate first.');
    latestCanvas.toBlob(b => saveAs(b,'passport.jpg'), 'image/jpeg', 0.92);
  });
  dlPsd.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Generate first.');
    try {
      const ab = createPsdFromCanvas(latestCanvas);
      const blob = new Blob([ab], {type:'application/octet-stream'});
      saveAs(blob,'passport.psd');
    } catch(err) {
      log('PSD export failed:', err.message || err);
      alert('PSD export failed in this browser. I can add server-side PSD builder if needed.');
    }
  });

  // draw scaled preview immediately after upload
  function drawPreviewScaled(img){
    const maxW = 360, maxH = 456;
    let w = img.width, h = img.height;
    const ratio = Math.min(maxW/w, maxH/h, 1);
    const dw = Math.round(w*ratio), dh = Math.round(h*ratio);
    preview.width = dw; preview.height = dh;
    ctx.clearRect(0,0,dw,dh);
    ctx.drawImage(img, 0,0,w,h, 0,0, dw,dh);
  }

  // main processing function
  async function applyAndProcess(){
    if(!originalImage) return alert('Please upload a photo first.');
    log('Processing started...');
    // working canvas
    const workW = Math.min(originalImage.width, 1200);
    const workH = Math.round(originalImage.height * (workW / originalImage.width));
    const work = document.createElement('canvas'); work.width = workW; work.height = workH;
    const wctx = work.getContext('2d');
    wctx.drawImage(originalImage, 0,0, workW, workH);

    // segmentation
    let compCanvas = document.createElement('canvas');
    compCanvas.width = workW; compCanvas.height = workH;
    const cctx = compCanvas.getContext('2d');

    if(!bodyPixNet){
      log('No segmentation model available — using original image with chosen bg fill.');
      // just fill background and draw original centered
      const chosenBg = chosenBgColor();
      cctx.fillStyle = chosenBg; cctx.fillRect(0,0,compCanvas.width,compCanvas.height);
      cctx.drawImage(work, 0,0);
    } else {
      log('Running segmentation...');
      // higher internalResolution improves edges (slower)
      const seg = await bodyPixNet.segmentPerson(work, {
        internalResolution: 'high',
        segmentationThreshold: 0.7,
        scoreThreshold: 0.3
      });
      log('Segmentation done.');

      // get mask and draw it
      const rawMask = bodyPix.toMask(seg, {r:255,g:255,b:255,a:255}, {r:0,g:0,b:0,a:0});
      const maskCanvas = document.createElement('canvas'); maskCanvas.width = workW; maskCanvas.height = workH;
      const mctx = maskCanvas.getContext('2d');
      mctx.putImageData(rawMask, 0,0);

      // feather / blur the mask for soft edges
      const blurPx = Number(feather.value) || 8;
      if('filter' in mctx) {
        // use an offscreen tmp to blur
        const tmp = document.createElement('canvas'); tmp.width = maskCanvas.width; tmp.height = maskCanvas.height;
        const tctx = tmp.getContext('2d');
        tctx.putImageData(rawMask, 0,0);
        tctx.filter = `blur(${blurPx}px)`;
        tctx.drawImage(tmp, 0,0);
        // replace maskCanvas with blurred tmp
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(tmp, 0,0);
      } else {
        // fallback simple scale trick
        const tmp = document.createElement('canvas'); tmp.width = maskCanvas.width; tmp.height = maskCanvas.height;
        const tctx = tmp.getContext('2d');
        tctx.putImageData(rawMask, 0,0);
        const scale = Math.max(1, Math.round(blurPx/2));
        const sw = Math.max(1, Math.floor(maskCanvas.width / scale));
        const sh = Math.max(1, Math.floor(maskCanvas.height / scale));
        const tiny = document.createElement('canvas'); tiny.width = sw; tiny.height = sh;
        const tinyCtx = tiny.getContext('2d');
        tinyCtx.drawImage(tmp, 0,0,sw,sh);
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(tiny, 0,0,sw,sh, 0,0,maskCanvas.width,maskCanvas.height);
      }

      // Composite: fill background then draw person pixels weighted by mask alpha
      const chosenBg = chosenBgColor();
      cctx.fillStyle = chosenBg; cctx.fillRect(0,0,compCanvas.width,compCanvas.height);

      const src = wctx.getImageData(0,0,workW,workH);
      const maskData = mctx.getImageData(0,0,maskCanvas.width,maskCanvas.height);
      const out = cctx.createImageData(compCanvas.width, compCanvas.height);
      // compose per-pixel
      for(let i=0;i<src.data.length;i+=4){
        const a = maskData.data[i+3]/255; // 1 => person
        // background RGB from chosenBg
        // compute bg rgb quickly
        // parse chosenBg hex
        // we'll precompute bg rgb below for speed; but simple: read existing fill via hexToRgb
      }

      // faster approach: draw mask as globalAlpha mask using compositing
      // create an offscreen person canvas
      const personCanvas = document.createElement('canvas'); personCanvas.width = workW; personCanvas.height = workH;
      const pctx = personCanvas.getContext('2d');
      // draw original image
      pctx.drawImage(work,0,0);
      // use maskCanvas as alpha mask by using destination-in trick
      pctx.globalCompositeOperation = 'destination-in';
      pctx.drawImage(maskCanvas,0,0);

      // now cctx already has filled background; draw personCanvas on top
      cctx.globalCompositeOperation = 'source-over';
      cctx.drawImage(personCanvas, 0,0);
      // reset composite operations
      pctx.globalCompositeOperation = 'source-over';
      cctx.globalCompositeOperation = 'source-over';
    }

    // apply brightness/contrast/sharpen on compCanvas
    applyFiltersToCanvas(compCanvas, Number(brightness.value), Number(contrast.value), Number(sharpen.value));

    // passport crop centered to target ratio and resize to EXPORT_W x EXPORT_H
    const targetRatio = EXPORT_W / EXPORT_H;
    let sx = 0, sy = 0, sw = compCanvas.width, sh = compCanvas.height;
    if(compCanvas.width / compCanvas.height > targetRatio){
      sw = Math.round(compCanvas.height * targetRatio);
      sx = Math.round((compCanvas.width - sw)/2);
    } else {
      sh = Math.round(compCanvas.width / targetRatio);
      sy = Math.round((compCanvas.height - sh)/2);
    }
    const final = document.createElement('canvas'); final.width = EXPORT_W; final.height = EXPORT_H;
    const fctx = final.getContext('2d');
    // background fill to avoid transparency fringes
    fctx.fillStyle = chosenBgColor();
    fctx.fillRect(0,0,final.width,final.height);
    fctx.drawImage(compCanvas, sx,sy, sw,sh, 0,0, final.width, final.height);

    // preview scaled
    preview.width = Math.min(420, final.width);
    preview.height = Math.round(preview.width * final.height / final.width);
    ctx.clearRect(0,0,preview.width,preview.height);
    ctx.drawImage(final, 0,0, final.width, final.height, 0,0, preview.width, preview.height);

    latestCanvas = final;
    log('Processing complete — export ready at ' + EXPORT_W + '×' + EXPORT_H + ' px.');
  }

  // helper returns hex bg color
  function chosenBgColor(){
    if(bgSelect.value === 'preset' || bgSelect.value === 'blue') return getComputedStyle(document.documentElement).getPropertyValue('--sample-blue') || '#5d8fe0';
    if(bgSelect.value === 'white') return '#ffffff';
    return bgColor.value || '#5d8fe0';
  }

  function chosenBgColor(){ // ensure returns visible hex
    if(bgSelect.value === 'preset' || bgSelect.value === 'blue') return '#5d8fe0';
    if(bgSelect.value === 'white') return '#ffffff';
    return bgColor.value || '#5d8fe0';
  }

  // image filters: brightness (add), contrast (scale), sharpen (convolution)
  function applyFiltersToCanvas(canvas, bright=0, contrastVal=0, sharpenAmt=0){
    const ctxL = canvas.getContext('2d');
    let img = ctxL.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const b = bright;
    const c = contrastVal/100;
    const contrastFactor = (259 * (c*255 + 255)) / (255 * (259 - c*255) || 1);
    for(let i=0;i<data.length;i+=4){
      data[i] = clamp( contrastFactor * (clamp(data[i] + b) - 128) + 128 );
      data[i+1] = clamp( contrastFactor * (clamp(data[i+1] + b) - 128) + 128 );
      data[i+2] = clamp( contrastFactor * (clamp(data[i+2] + b) - 128) + 128 );
    }
    ctxL.putImageData(img,0,0);

    if(sharpenAmt > 0.01){
      const w = canvas.width, h = canvas.height;
      const src = ctxL.getImageData(0,0,w,h);
      const dst = ctxL.createImageData(w,h);
      const s = sharpenAmt;
      const k = [0,-s,0,-s,1+4*s,-s,0,-s,0];
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let r=0,g=0,bv=0,idx=0;
          for(let ky=-1;ky<=1;ky++){
            for(let kx=-1;kx<=1;kx++){
              const px = x + kx, py = y + ky;
              const pidx = (py*w + px)*4;
              const kval = k[idx++];
              r += src.data[pidx+0]*kval;
              g += src.data[pidx+1]*kval;
              bv += src.data[pidx+2]*kval;
            }
          }
          const di = (y*w + x)*4;
          dst.data[di+0] = clamp(Math.round(r));
          dst.data[di+1] = clamp(Math.round(g));
          dst.data[di+2] = clamp(Math.round(bv));
          dst.data[di+3] = 255;
        }
      }
      ctxL.putImageData(dst,0,0);
    }
  }

  function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }
  function id(i){ return document.getElementById(i); }

  // create PSD (single flattened layer) using ag-psd (canvas)
  function createPsdFromCanvas(canvas){
    const ag = window['agPsd'];
    if(!ag || !ag.encodePsd) throw new Error('ag-psd not available');
    const w = canvas.width, h = canvas.height;
    const psd = {width:w,height:h,children:[{name:'Layer 1',left:0,top:0,right:w,bottom:h,canvas:canvas}]};
    return ag.encodePsd(psd);
  }

  // expose saveAs (FileSaver)
  function saveAs(blob, name){ try{ window.saveAs(blob, name); }catch(e){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href); } }

})();
</script>
</body>
</html>
