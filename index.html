<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Passport Size Pic Generator — Advanced (ResNet50)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Orbitron:wght@600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#041018;
    --panel:#071824;
    --accent1:#00e6ff;
    --accent2:#b86bff;
    --sample-blue:#5d8fe0;
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Arial;margin:0;background:linear-gradient(180deg,#031017 0%, #041018 60%);color:#dbeef7;padding:20px}
  .wrap{max-width:1100px;margin:0 auto}
  h1{font-family:Orbitron, sans-serif;color:var(--accent1);margin:0 0 12px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03)); padding:16px;border-radius:12px; box-shadow: 0 8px 30px rgba(11,20,30,0.6);}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:18px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .right{order:-1} }

  .uploader{display:flex;gap:12px;align-items:center}
  input[type="file"]{background:#0b2028;color:#bff6ff;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  .btn{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#071824;padding:10px 14px;border-radius:30px;text-decoration:none;border:none;font-weight:700;cursor:pointer}
  .small{padding:8px 10px;border-radius:8px;background:#0b2028;color:var(--accent1);border:1px solid rgba(0,230,255,0.06);cursor:pointer}
  .controls{display:flex;flex-direction:column;gap:10px;margin-top:12px}
  .row{display:flex;gap:8px;align-items:center}
  label{min-width:110px;color:#9ad9ea;font-size:14px}
  input[type=range]{flex:1}
  canvas{background:#0c1b22;border-radius:8px;display:block;width:100%;height:auto;max-width:420px}
  .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .log{font-size:13px;color:#9ad9ea;min-height:220px;white-space:pre-wrap;overflow:auto;padding:12px;background:rgba(255,255,255,0.01);border-radius:8px}
  footer{margin-top:16px;color:#7fb5c9;font-size:13px}
  .hint{font-size:13px;color:#8fbfd0}
</style>
</head>
<body>
<div class="wrap">
  <h1>Passport Size Pic Generator — Advanced</h1>

  <div class="grid">
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:700;color:#bff6ff">Upload a portrait</div>
            <div class="hint">ResNet50 model will run in-browser (more accurate). Background removal → feather → despill → composite.</div>
          </div>
          <div class="uploader">
            <input id="fileInput" type="file" accept="image/*">
            <button id="autoProcess" class="btn">Auto Process</button>
          </div>
        </div>

        <div style="margin-top:12px;display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap">
          <div>
            <canvas id="preview" width="360" height="456"></canvas>
            <div style="margin-top:8px;color:#9ad9ea;font-size:13px">Preview (export 450×570 px)</div>
          </div>

          <div style="min-width:260px;flex:1">
            <div class="controls">
              <div class="row">
                <label>Background</label>
                <select id="bgSelect">
                  <option value="preset">Match sample blue</option>
                  <option value="white">White</option>
                  <option value="custom">Custom</option>
                </select>
                <input id="bgColor" type="color" value="#5d8fe0" style="display:none">
              </div>

              <div class="row">
                <label>Brightness</label>
                <input id="brightness" type="range" min="-80" max="80" value="10">
                <div id="bVal" style="width:40px;text-align:right">+10</div>
              </div>

              <div class="row">
                <label>Contrast</label>
                <input id="contrast" type="range" min="-80" max="80" value="6">
                <div id="cVal" style="width:40px;text-align:right">+6</div>
              </div>

              <div class="row">
                <label>Sharpen</label>
                <input id="sharpen" type="range" min="0" max="3" step="0.25" value="1">
                <div id="sVal" style="width:40px;text-align:right">1.0</div>
              </div>

              <div class="row">
                <label>Feather (edge)</label>
                <input id="feather" type="range" min="0" max="20" value="8">
                <div id="fVal" style="width:40px;text-align:right">8px</div>
              </div>

              <div class="actions">
                <button id="applyBtn" class="btn">Apply & Generate</button>
                <button id="dlPng" class="small">Download PNG (450×570)</button>
                <button id="dlJpg" class="small">Download JPG</button>
                <button id="dlPsd" class="small">Download PSD (single-layer)</button>
                <button id="resetBtn" class="small">Reset</button>
              </div>

              <div class="hint" style="margin-top:6px">Export: 1.5 × 1.9 in @ 300 DPI = 450 × 570 px. ResNet50 is heavier but gives better masks — please be patient while model loads.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <strong style="color:#bff6ff">Preview / Logs</strong>
        <div id="log" class="log">Loading BodyPix ResNet50 model...</div>
      </div>

      <div style="height:12px"></div>

      <div class="panel">
        <strong style="color:#bff6ff">How it works</strong>
        <ol style="color:#9ad9ea">
          <li>Load BodyPix ResNet50 in browser (high accuracy)</li>
          <li>Segment person → refine mask (erode/dilate trick) → blur (feather)</li>
          <li>Composite on blue → despill (remove blue fringe) → apply filters → crop → export</li>
        </ol>
      </div>
    </div>
  </div>

  <footer>Client-only solution. For production-grade layered PSD & perfect hair, server-side matting is recommended (I can implement that too).</footer>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ag-psd@12.0.0/dist/ag-psd.umd.min.js"></script>

<script>
(async function(){
  // DOM refs
  const fileInput = id('fileInput'), autoProcess = id('autoProcess');
  const preview = id('preview'), ctx = preview.getContext('2d');
  const applyBtn = id('applyBtn'), resetBtn = id('resetBtn');
  const dlPng = id('dlPng'), dlJpg = id('dlJpg'), dlPsd = id('dlPsd');
  const bgSelect = id('bgSelect'), bgColor = id('bgColor');
  const brightness = id('brightness'), contrast = id('contrast'), sharpen = id('sharpen');
  const feather = id('feather');
  const bVal = id('bVal'), cVal = id('cVal'), sVal = id('sVal'), fVal = id('fVal');
  const logEl = id('log');

  function log(...t){ logEl.textContent += t.join(' ') + "\\n"; logEl.scrollTop = 9999; }

  const EXPORT_W = 450, EXPORT_H = 570;
  let originalImage = null;
  let bodyPixNet = null;
  let latestCanvas = null;

  // load ResNet50 BodyPix for higher accuracy
  log('Loading BodyPix (ResNet50) — this may take 5–20 seconds depending on connection...');
  try{
    bodyPixNet = await bodyPix.load({
      architecture: 'ResNet50',
      outputStride: 16,
      quantBytes: 2 // reduce weight slightly; change to 1 for smaller but lower precision
    });
    log('BodyPix ResNet50 loaded.');
  }catch(e){
    log('Model load failed:', e.message || e);
    bodyPixNet = null;
  }

  // UI events
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      drawPreviewScaled(img);
      URL.revokeObjectURL(url);
      log('Image loaded: ' + img.width + '×' + img.height);
    };
    img.src = url;
  });

  autoProcess.addEventListener('click', ()=> applyAndProcess());
  applyBtn.addEventListener('click', ()=> applyAndProcess());
  resetBtn.addEventListener('click', ()=> {
    originalImage = null; ctx.clearRect(0,0,preview.width,preview.height); fileInput.value=''; log('Reset.');
  });

  bgSelect.addEventListener('change', ()=> { bgColor.style.display = bgSelect.value === 'custom' ? 'inline-block' : 'none'; });
  brightness.addEventListener('input', ()=> bVal.textContent = (brightness.value>0?'+':'')+brightness.value);
  contrast.addEventListener('input', ()=> cVal.textContent = (contrast.value>0?'+':'')+contrast.value);
  sharpen.addEventListener('input', ()=> sVal.textContent = sharpen.value);
  feather.addEventListener('input', ()=> fVal.textContent = feather.value + 'px');

  dlPng.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Generate first.');
    latestCanvas.toBlob(b => saveAs(b,'passport.png'), 'image/png');
  });
  dlJpg.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Generate first.');
    latestCanvas.toBlob(b => saveAs(b,'passport.jpg'), 'image/jpeg', 0.92);
  });
  dlPsd.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Generate first.');
    try {
      const ab = createPsdFromCanvas(latestCanvas);
      const blob = new Blob([ab], {type:'application/octet-stream'});
      saveAs(blob,'passport.psd');
    } catch(err) {
      log('PSD export failed:', err.message || err);
      alert('PSD export failed in this browser. I can add server-side PSD builder if needed.');
    }
  });

  // draw scaled preview on upload
  function drawPreviewScaled(img){
    const maxW = 360, maxH = 456;
    let w = img.width, h = img.height;
    const ratio = Math.min(maxW/w, maxH/h, 1);
    const dw = Math.round(w*ratio), dh = Math.round(h*ratio);
    preview.width = dw; preview.height = dh;
    ctx.clearRect(0,0,dw,dh);
    ctx.drawImage(img, 0,0,w,h, 0,0, dw,dh);
  }

  // helper: hex->rgb
  function hexToRgb(hex){
    hex = hex.replace('#','');
    if(hex.length===3) hex = hex.split('').map(s=>s+s).join('');
    return { r: parseInt(hex.substring(0,2),16), g: parseInt(hex.substring(2,4),16), b: parseInt(hex.substring(4,6),16) };
  }

  function chosenBgColor(){
    if(bgSelect.value === 'preset') return '#5d8fe0';
    if(bgSelect.value === 'white') return '#ffffff';
    return bgColor.value || '#5d8fe0';
  }

  // despill: reduce background-color spill (simple heuristic)
  function despill(canvas, bgHex='#5d8fe0', strength=0.7){
    const ctxLocal = canvas.getContext('2d');
    const img = ctxLocal.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const bg = hexToRgb(bgHex);
    for(let i=0;i<data.length;i+=4){
      const r = data[i], g = data[i+1], b = data[i+2];
      // detect bluish fringe: blue significantly higher than red/green
      if (b > r + 18 && b > g + 18) {
        // compute how much to reduce blue based on difference and strength
        const diff = Math.min(255, b - Math.max(r,g));
        const reduce = Math.round(diff * strength * 0.9);
        data[i+2] = clamp(b - reduce);
        // optionally boost r/g slightly for natural look
        data[i] = clamp(r + Math.round(reduce * 0.12));
        data[i+1] = clamp(g + Math.round(reduce * 0.06));
      }
    }
    ctxLocal.putImageData(img,0,0);
  }

  // main function
  async function applyAndProcess(){
    if(!originalImage) return alert('Please upload a photo first.');
    log('Processing started...');
    // working canvas resolution (limit)
    const workW = Math.min(originalImage.width, 1400);
    const workH = Math.round(originalImage.height * (workW / originalImage.width));
    const work = document.createElement('canvas'); work.width = workW; work.height = workH;
    const wctx = work.getContext('2d');
    wctx.drawImage(originalImage, 0,0, workW, workH);

    // composite canvas
    const comp = document.createElement('canvas'); comp.width = workW; comp.height = workH;
    const cctx = comp.getContext('2d');

    if(!bodyPixNet){
      log('No segmentation model; skipping background removal.');
      cctx.fillStyle = chosenBgColor(); cctx.fillRect(0,0,comp.width,comp.height);
      cctx.drawImage(work, 0,0);
    } else {
      log('Running segmentation (ResNet50) — this may take a few seconds...');
      const seg = await bodyPixNet.segmentPerson(work, {
        internalResolution: 'high',
        segmentationThreshold: 0.7,
        scoreThreshold: 0.3
      });
      log('Segmentation done.');

      // raw mask -> maskCanvas
      const rawMask = bodyPix.toMask(seg, {r:255,g:255,b:255,a:255}, {r:0,g:0,b:0,a:0});
      const maskCanvas = document.createElement('canvas'); maskCanvas.width = workW; maskCanvas.height = workH;
      const mctx = maskCanvas.getContext('2d');
      mctx.putImageData(rawMask, 0,0);

      // refine mask: small erode (downscale/upscale trick) to remove speckles
      const erodeFactor = Math.max(1, Math.round((feather.value/12) + 1)); // tweak
      if(erodeFactor > 1){
        const tmp = document.createElement('canvas'); tmp.width = Math.max(1,Math.floor(workW/erodeFactor)); tmp.height = Math.max(1,Math.floor(workH/erodeFactor));
        tmp.getContext('2d').drawImage(maskCanvas,0,0,tmp.width,tmp.height);
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(tmp,0,0,tmp.width,tmp.height, 0,0, maskCanvas.width, maskCanvas.height);
      }

      // blur mask (feather)
      const blurPx = Number(feather.value) || 8;
      if('filter' in mctx){
        const tmp2 = document.createElement('canvas'); tmp2.width = maskCanvas.width; tmp2.height = maskCanvas.height;
        const tctx = tmp2.getContext('2d');
        tctx.putImageData(mctx.getImageData(0,0,maskCanvas.width,maskCanvas.height), 0, 0);
        tctx.filter = `blur(${blurPx}px)`;
        tctx.drawImage(tmp2, 0, 0);
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(tmp2, 0, 0);
      } else {
        // fallback: tiny downscale/upscale trick
        const tmp2 = document.createElement('canvas'); tmp2.width = Math.max(1,Math.floor(maskCanvas.width/4)); tmp2.height = Math.max(1,Math.floor(maskCanvas.height/4));
        tmp2.getContext('2d').drawImage(maskCanvas,0,0,tmp2.width,tmp2.height);
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(tmp2,0,0,tmp2.width,tmp2.height, 0,0,maskCanvas.width, maskCanvas.height);
      }

      // Create person canvas via destination-in (keeps alpha)
      const personCanvas = document.createElement('canvas'); personCanvas.width = workW; personCanvas.height = workH;
      const pctx = personCanvas.getContext('2d');
      pctx.drawImage(work, 0,0);
      pctx.globalCompositeOperation = 'destination-in';
      pctx.drawImage(maskCanvas, 0,0);
      pctx.globalCompositeOperation = 'source-over';

      // composite over chosen background
      cctx.fillStyle = chosenBgColor(); cctx.fillRect(0,0,comp.width,comp.height);
      cctx.drawImage(personCanvas, 0,0);

      // despill to reduce blue halo
      despill(comp, chosenBgColor(), 0.8);
    }

    // apply bright/contrast/sharpen on comp
    applyFiltersToCanvas(comp, Number(brightness.value), Number(contrast.value), Number(sharpen.value));

    // passport crop and resize to EXPORT_W x EXPORT_H
    const targetRatio = EXPORT_W / EXPORT_H;
    let sx = 0, sy = 0, sw = comp.width, sh = comp.height;
    if(comp.width / comp.height > targetRatio){
      sw = Math.round(comp.height * targetRatio); sx = Math.round((comp.width - sw)/2);
    } else {
      sh = Math.round(comp.width / targetRatio); sy = Math.round((comp.height - sh)/2);
    }
    const final = document.createElement('canvas'); final.width = EXPORT_W; final.height = EXPORT_H;
    const fctx = final.getContext('2d');
    fctx.fillStyle = chosenBgColor(); fctx.fillRect(0,0,final.width,final.height);
    fctx.drawImage(comp, sx,sy, sw,sh, 0,0, final.width, final.height);

    // preview scaled
    preview.width = Math.min(420, final.width); preview.height = Math.round(preview.width * final.height / final.width);
    ctx.clearRect(0,0,preview.width,preview.height);
    ctx.drawImage(final, 0,0, final.width, final.height, 0,0, preview.width, preview.height);

    latestCanvas = final;
    log('Processing complete — export ready at ' + EXPORT_W + '×' + EXPORT_H + ' px.');
  }

  // image filters: brightness (add), contrast (scale), sharpen (convolution)
  function applyFiltersToCanvas(canvas, bright=0, contrastVal=0, sharpenAmt=0){
    const ctxL = canvas.getContext('2d');
    let img = ctxL.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const b = bright;
    const c = contrastVal/100;
    const contrastFactor = (259 * (c*255 + 255)) / (255 * (259 - c*255) || 1);
    for(let i=0;i<data.length;i+=4){
      data[i] = clamp( contrastFactor * (clamp(data[i] + b) - 128) + 128 );
      data[i+1] = clamp( contrastFactor * (clamp(data[i+1] + b) - 128) + 128 );
      data[i+2] = clamp( contrastFactor * (clamp(data[i+2] + b) - 128) + 128 );
    }
    ctxL.putImageData(img,0,0);

    if(sharpenAmt > 0.01){
      const w = canvas.width, h = canvas.height;
      const src = ctxL.getImageData(0,0,w,h);
      const dst = ctxL.createImageData(w,h);
      const s = sharpenAmt;
      const k = [0,-s,0,-s,1+4*s,-s,0,-s,0];
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let r=0,g=0,bv=0,idx=0;
          for(let ky=-1;ky<=1;ky++){
            for(let kx=-1;kx<=1;kx++){
              const px = x + kx, py = y + ky;
              const pidx = (py*w + px)*4;
              const kval = k[idx++];
              r += src.data[pidx+0]*kval;
              g += src.data[pidx+1]*kval;
              bv += src.data[pidx+2]*kval;
            }
          }
          const di = (y*w + x)*4;
          dst.data[di+0] = clamp(Math.round(r));
          dst.data[di+1] = clamp(Math.round(g));
          dst.data[di+2] = clamp(Math.round(bv));
          dst.data[di+3] = 255;
        }
      }
      ctxL.putImageData(dst,0,0);
    }
  }

  function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }
  function id(i){ return document.getElementById(i); }

  // create PSD (single flattened layer) using ag-psd (canvas)
  function createPsdFromCanvas(canvas){
    const ag = window['agPsd'];
    if(!ag || !ag.encodePsd) throw new Error('ag-psd not available');
    const w = canvas.width, h = canvas.height;
    const psd = {width:w,height:h,children:[{name:'Layer 1',left:0,top:0,right:w,bottom:h,canvas:canvas}]};
    return ag.encodePsd(psd);
  }

  // saveAs
  function saveAs(blob, name){ try{ window.saveAs(blob, name); }catch(e){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href); } }

})();
</script>
</body>
</html>
