<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Passport Size Pic Generator — PixelKit</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  body{font-family:Inter,system-ui,Arial;background:#071923;color:#dff6ff;margin:0;padding:18px}
  .wrap{max-width:980px;margin:0 auto}
  h1{color:#6fe9ff;margin:0 0 14px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03)); padding:16px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .uploader{display:flex;gap:8px;align-items:center}
  input[type=file]{background:#0b2630;color:#bff6ff;padding:8px;border-radius:8px}
  .btn{background:linear-gradient(90deg,#00e6ff,#b86bff);color:#071824;padding:8px 12px;border-radius:20px;border:none;cursor:pointer;font-weight:700}
  .small{background:#0b2b34;color:#8fe0f0;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
  canvas{max-width:100%;border-radius:6px;background:#0d1b20}
  .controls{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  label{color:#9edbef;min-width:110px}
  .row{display:flex;gap:8px;align-items:center}
  footer{margin-top:14px;color:#7fb5c9;font-size:13px}
  .log{font-size:13px;color:#9ad9ea;min-height:160px;white-space:pre-wrap;overflow:auto;padding:8px;background:rgba(255,255,255,0.01);border-radius:8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Passport Size Pic Generator</h1>

  <div class="grid">
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <strong style="color:#bff6ff">Upload photo</strong>
            <div style="font-size:13px;color:#9ad9ea">Any portrait — background will be removed automatically</div>
          </div>
          <div class="uploader">
            <input id="file" type="file" accept="image/*">
            <button id="autoBtn" class="btn">Auto Process</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <canvas id="preview" width="300" height="380"></canvas>
          <div style="margin-top:8px" class="controls">
            <div class="row">
              <label>Background</label>
              <select id="bgOpt">
                <option value="preset">Match sample blue</option>
                <option value="white">White</option>
                <option value="custom">Custom</option>
              </select>
              <input id="bgColor" type="color" value="#5d8fe0" style="display:none;margin-left:6px">
            </div>

            <div class="row">
              <label>Brightness</label>
              <input id="brightness" type="range" min="-80" max="80" value="10" style="flex:1">
              <span id="bVal" style="width:40px;text-align:right">+10</span>
            </div>

            <div class="row">
              <label>Contrast</label>
              <input id="contrast" type="range" min="-80" max="80" value="6" style="flex:1">
              <span id="cVal" style="width:40px;text-align:right">+6</span>
            </div>

            <div class="row">
              <label>Sharpen</label>
              <input id="sharpen" type="range" min="0" max="3" step="0.25" value="1" style="flex:1">
              <span id="sVal" style="width:40px;text-align:right">1.0</span>
            </div>

            <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
              <button id="apply" class="btn">Apply & Generate</button>
              <button id="dlPng" class="small">Download PNG (450×570px)</button>
              <button id="dlJpg" class="small">Download JPG</button>
              <button id="dlPsd" class="small">Download PSD (single-layer)</button>
              <button id="reset" class="small">Reset</button>
            </div>

            <div style="font-size:13px;color:#9ad9ea;margin-top:6px">Export size: 1.5 × 1.9 in @ 300 DPI → 450 × 570 px</div>
          </div>
        </div>
      </div>
    </div>

    <div>
      <div class="panel">
        <strong style="color:#bff6ff">Preview / Logs</strong>
        <div id="log" class="log"></div>
      </div>
    </div>
  </div>

  <footer>Note: Client-side removal uses BodyPix (works best with clear portrait). For complex backgrounds, server-side removal (remove.bg or other API) gives better results.</footer>
</div>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ag-psd@12.0.0/dist/ag-psd.umd.min.js"></script>

<script>
(async function(){
  const logEl = id('log');
  function log(...t){ logEl.textContent += t.join(' ') + '\\n'; logEl.scrollTop = 9999; }

  // DOM
  const file = id('file'), preview = id('preview'), ctx = preview.getContext('2d');
  const autoBtn = id('autoBtn'), applyBtn = id('apply'), resetBtn = id('reset');
  const dlPng = id('dlPng'), dlJpg = id('dlJpg'), dlPsd = id('dlPsd');
  const bgOpt = id('bgOpt'), bgColor = id('bgColor');
  const brightness = id('brightness'), contrast = id('contrast'), sharpen = id('sharpen');
  const bVal = id('bVal'), cVal = id('cVal'), sVal = id('sVal');

  // default target export size (px): 1.5 x 1.9 inch @ 300dpi
  const EXPORT_W = 450, EXPORT_H = 570;

  let img = null;
  let bodyPixNet = null;
  let latestCanvas = document.createElement('canvas');

  // load model
  log('Loading BodyPix model...');
  try{
    bodyPixNet = await bodyPix.load({architecture:'MobileNetV1',multiplier:0.75,outputStride:16});
    log('Model loaded.');
  }catch(e){ log('Model load failed:', e.message || e); }

  file.addEventListener('change', async(e)=>{
    const f = e.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f); const im = new Image();
    im.onload = ()=>{ img = im; drawPreviewInitial(); URL.revokeObjectURL(url); log('Image loaded:', im.width + 'x' + im.height); };
    im.src = url;
  });

  autoBtn.addEventListener('click', ()=> applyAndProcess());
  applyBtn.addEventListener('click', ()=> applyAndProcess());
  resetBtn.addEventListener('click', ()=> { img=null; ctx.clearRect(0,0,preview.width,preview.height); file.value=''; log('Reset'); });

  bgOpt.addEventListener('change', ()=> { bgColor.style.display = bgOpt.value==='custom' ? 'inline-block' : 'none'; });
  brightness.addEventListener('input', ()=> bVal.textContent = (brightness.value>0?'+':'') + brightness.value);
  contrast.addEventListener('input', ()=> cVal.textContent = (contrast.value>0?'+':'') + contrast.value);
  sharpen.addEventListener('input', ()=> sVal.textContent = sharpen.value);

  dlPng.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Please generate first.');
    latestCanvas.toBlob(b => saveAs(b,'passport.png'));
  });
  dlJpg.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Please generate first.');
    latestCanvas.toBlob(b => saveAs(b,'passport.jpg'),'image/jpeg',0.92);
  });
  dlPsd.addEventListener('click', ()=> {
    if(!latestCanvas) return alert('Please generate first.');
    try{
      const ab = createPsdFromCanvas(latestCanvas);
      const blob = new Blob([ab],{type:'application/octet-stream'});
      saveAs(blob,'passport.psd');
    }catch(e){ log('PSD export error', e.message || e); alert('PSD export failed in this browser.'); }
  });

  function drawPreviewInitial(){
    // show scaled preview while not processed
    const maxW = 360, maxH = 480;
    let w = img.width, h = img.height;
    const ratio = Math.min(maxW/w, maxH/h, 1);
    const dw = Math.round(w*ratio), dh = Math.round(h*ratio);
    preview.width = dw; preview.height = dh;
    ctx.clearRect(0,0,dw,dh);
    ctx.drawImage(img,0,0,w,h,0,0,dw,dh);
  }

  async function applyAndProcess(){
    if(!img) return alert('Upload an image first.');
    log('Processing started...');
    // prepare working canvas at reasonable resolution (limit for performance)
    const targetW = Math.min(img.width, 1200);
    const targetH = Math.round(img.height * targetW / img.width);
    const work = document.createElement('canvas'); work.width = targetW; work.height = targetH;
    const wctx = work.getContext('2d'); wctx.drawImage(img,0,0,targetW,targetH);

    // segmentation
    if(!bodyPixNet){ log('Segmentation model not available — skipping BG removal'); }
    else {
      log('Running segmentation...');
      const seg = await bodyPixNet.segmentPerson(work, {internalResolution:'medium',segmentationThreshold:0.7});
      log('Segmentation done.');
      // build mask and composite person over chosen background color
      const mask = document.createElement('canvas'); mask.width = work.width; mask.height = work.height;
      const mctx = mask.getContext('2d');
      const imgData = mctx.createImageData(mask.width, mask.height);
      for(let i=0;i<seg.data.length;i++){
        const person = seg.data[i];
        imgData.data[i*4+0] = imgData.data[i*4+1] = imgData.data[i*4+2] = person ? 255 : 0;
        imgData.data[i*4+3] = person ? 255 : 0;
      }
      mctx.putImageData(imgData,0,0);

      // composite
      const comp = document.createElement('canvas'); comp.width = work.width; comp.height = work.height;
      const cctx = comp.getContext('2d');
      // chosen bg color
      const chosen = bgOpt.value==='preset' ? '#5d8fe0' : (bgOpt.value==='white' ? '#ffffff' : bgColor.value);
      cctx.fillStyle = chosen; cctx.fillRect(0,0,comp.width,comp.height);

      // copy person pixels using mask alpha
      const src = wctx.getImageData(0,0,work.width,work.height);
      const maskD = mctx.getImageData(0,0,mask.width,mask.height);
      const out = cctx.createImageData(comp.width, comp.height);
      for(let i=0;i<src.data.length;i+=4){
        const a = maskD.data[i+3]/255;
        out.data[i+0] = src.data[i+0]*a + 255*(1-a)*0;
        out.data[i+1] = src.data[i+1]*a + 255*(1-a)*0;
        out.data[i+2] = src.data[i+2]*a + 255*(1-a)*0;
        out.data[i+3] = 255;
      }
      cctx.putImageData(out,0,0);
      // replace work with comp
      work.width = comp.width; work.height = comp.height;
      wctx.clearRect(0,0,work.width,work.height); wctx.drawImage(comp,0,0);
    }

    // apply filters (brightness, contrast, sharpen)
    applyFilters(work, Number(brightness.value), Number(contrast.value), Number(sharpen.value));

    // passport crop to 1.5:1.9 ratio centered, then resize to EXPORT_W x EXPORT_H
    const targetRatio = 1.5/1.9;
    let sx = 0, sy = 0, sw = work.width, sh = work.height;
    // compute crop box maintaining ratio
    if(work.width / work.height > targetRatio){
      // too wide -> reduce width
      sw = Math.round(work.height * targetRatio);
      sx = Math.round((work.width - sw)/2);
    } else {
      // too tall -> reduce height
      sh = Math.round(work.width / targetRatio);
      sy = Math.round((work.height - sh)/2);
    }
    const final = document.createElement('canvas'); final.width = EXPORT_W; final.height = EXPORT_H;
    const fctx = final.getContext('2d');
    // fill background (to cover transparent edges)
    const chosenBG = bgOpt.value==='preset' ? '#5d8fe0' : (bgOpt.value==='white' ? '#ffffff' : bgColor.value);
    fctx.fillStyle = chosenBG; fctx.fillRect(0,0,final.width,final.height);
    fctx.drawImage(work, sx,sy,sw,sh, 0,0, final.width, final.height);

    // show preview scaled
    preview.width = Math.min(360, final.width); preview.height = Math.round(preview.width * final.height / final.width);
    ctx.clearRect(0,0,preview.width,preview.height);
    ctx.drawImage(final,0,0,final.width,final.height, 0,0, preview.width, preview.height);

    latestCanvas = final;
    log('Done. Export ready at ' + EXPORT_W + '×' + EXPORT_H + ' px.');
  }

  // filters: brightness add, contrast scale, sharpen convolution
  function applyFilters(canvas, bright=0, contrastV=0, sharpenAmt=0){
    const ctxL = canvas.getContext('2d');
    let img = ctxL.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const b = bright;
    const c = contrastV/100;
    const contrastFactor = (259 * (c*255 + 255)) / (255 * (259 - c*255) || 1);
    for(let i=0;i<data.length;i+=4){
      data[i] = clamp( contrastFactor * (clamp(data[i] + b) - 128) + 128 );
      data[i+1] = clamp( contrastFactor * (clamp(data[i+1] + b) - 128) + 128 );
      data[i+2] = clamp( contrastFactor * (clamp(data[i+2] + b) - 128) + 128 );
    }
    ctxL.putImageData(img,0,0);

    if(sharpenAmt > 0.01){
      // simple sharpen kernel
      const w = canvas.width, h = canvas.height;
      const src = ctxL.getImageData(0,0,w,h);
      const dst = ctxL.createImageData(w,h);
      const s = sharpenAmt;
      // kernel: center (1+4s), neighbors -s
      const k = [0,-s,0,-s,1+4*s,-s,0,-s,0];
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let r=0,g=0,bv=0,idx=0;
          for(let ky=-1;ky<=1;ky++){
            for(let kx=-1;kx<=1;kx++){
              const px = x+kx, py = y+ky;
              const pidx = (py*w + px)*4;
              const kval = k[idx++];
              r += src.data[pidx+0]*kval;
              g += src.data[pidx+1]*kval;
              bv += src.data[pidx+2]*kval;
            }
          }
          const di = (y*w + x)*4;
          dst.data[di+0] = clamp(Math.round(r));
          dst.data[di+1] = clamp(Math.round(g));
          dst.data[di+2] = clamp(Math.round(bv));
          dst.data[di+3] = 255;
        }
      }
      ctxL.putImageData(dst,0,0);
    }
  }

  function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }
  function id(i){ return document.getElementById(i); }

  // create PSD (single flattened layer) using ag-psd
  function createPsdFromCanvas(canvas){
    const ag = window['agPsd'];
    if(!ag || !ag.encodePsd) throw new Error('ag-psd missing');
    const w = canvas.width, h = canvas.height;
    const psd = {width:w,height:h,children:[{name:'Layer 1',left:0,top:0,right:w,bottom:h,canvas:canvas}]};
    return ag.encodePsd(psd);
  }

})();
</script>
</body>
</html>
